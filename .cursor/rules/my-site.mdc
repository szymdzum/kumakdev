---
description: 
globs: 
alwaysApply: true
---

# Your rule content

Always use semantic HTML. 
Use vanilla CSS. 
Always create Astro components. 

Take the full advantage of Astro capabilities. Embrace TypeScript and speed. 

# Comprehensive Astro Tutorial Guide: Best Practices

Astro is a modern web framework for building content-focused, fast websites. This guide will walk you through the essentials of Astro, from installation to deployment, following best practices throughout.

## Table of Contents

1. [Introduction to Astro](mdc:#introduction-to-astro)
2. [Getting Started](mdc:#getting-started)
   - [System Requirements](mdc:#system-requirements)
   - [Creating a New Project](mdc:#creating-a-new-project)
   - [Project Structure](mdc:#project-structure)
3. [Core Concepts](mdc:#core-concepts)
   - [Components](mdc:#components)
   - [Pages](mdc:#pages)
   - [Layouts](mdc:#layouts)
   - [Astro Islands](mdc:#astro-islands)
4. [Building Your UI](mdc:#building-your-ui)
   - [Astro Component Syntax](mdc:#astro-component-syntax)
   - [Props](mdc:#props)
   - [Slots](mdc:#slots)
   - [Styling in Astro](mdc:#styling-in-astro)
5. [Adding Content](mdc:#adding-content)
   - [Markdown Integration](mdc:#markdown-integration)
   - [Content Collections](mdc:#content-collections)
   - [Image Optimization](mdc:#image-optimization)
   - [Data Fetching](mdc:#data-fetching)
6. [Integrations and Frameworks](mdc:#integrations-and-frameworks)
   - [UI Frameworks (React, Vue, Svelte, etc.)](mdc:#ui-frameworks)
   - [Adding Tailwind CSS](mdc:#adding-tailwind-css)
7. [Routing and Navigation](mdc:#routing-and-navigation)
   - [File-based Routing](mdc:#file-based-routing)
   - [Dynamic Routes](mdc:#dynamic-routes)
   - [View Transitions](mdc:#view-transitions)
8. [Optimizing Your Site](mdc:#optimizing-your-site)
   - [Performance Optimization](mdc:#performance-optimization)
   - [SEO Best Practices](mdc:#seo-best-practices)
9. [Deployment](mdc:#deployment)
   - [Static Site Generation](mdc:#static-site-generation)
   - [Server-side Rendering](mdc:#server-side-rendering)
   - [Deployment Platforms](mdc:#deployment-platforms)
10. [Advanced Topics](mdc:#advanced-topics)
    - [Environment Variables](mdc:#environment-variables)
    - [TypeScript Integration](mdc:#typescript-integration)
    - [Middleware](mdc:#middleware)
    - [Internationalization (i18n)](mdc:#internationalization)

## Introduction to Astro

Astro is a modern web framework designed to build fast, content-focused websites. Unlike other frameworks that are heavily client-side focused, Astro takes a different approach:

- **Zero JavaScript by default**: Astro ships zero JavaScript to the client by default, resulting in faster page loads.
- **Islands Architecture**: Allows you to use components from popular frameworks like React, Vue, and Svelte, but only hydrates them when necessary.
- **Server-first**: Performs most work at build time or on the server rather than in the browser.
- **Content-focused**: Built with content-rich websites in mind (blogs, documentation, marketing sites, etc.).

## Getting Started

### System Requirements

Before you begin, ensure you have:

- **Node.js** - `v18.17.1` or `v20.3.0`, `v22.0.0` or higher. (`v19` and `v21` are not supported.)
- **Text editor** - VS Code with the [Official Astro extension](mdc:https:/marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) is recommended.
- **Terminal** - Astro is accessed through its command-line interface (CLI).

### Creating a New Project

You can create a new Astro project using the following command:

```bash
# Using npm
npm create astro@latest

# Using pnpm
pnpm create astro@latest

# Using Yarn
yarn create astro
```

This command will guide you through the setup process:
1. Enter a project name
2. Choose a starter template (you can select "Empty" for a minimal starting point)
3. Choose whether to install dependencies
4. Initialize a git repository (optional)
5. Add TypeScript (recommended)

After installation, navigate to your project directory and start the development server:

```bash
cd my-astro-project
npm run dev
```

Visit `http://localhost:4321` to see your site in action.

### Project Structure

An Astro project has a specific file structure:

```
my-astro-project/
├── public/             # Static assets that don't need processing
│   └── favicon.svg
├── src/                # Source code
│   ├── components/     # Reusable UI components
│   ├── layouts/        # Page layouts
│   └── pages/          # File-based routing
│       └── index.astro # Home page
├── astro.config.mjs    # Astro configuration
├── package.json        # Project dependencies
└── tsconfig.json       # TypeScript configuration
```

**Key directories explained:**

- **`src/`**: Contains all your source code and assets that need processing.
  - **`src/pages/`**: Each `.astro`, `.md`, `.mdx`, or `.html` file becomes a route based on its filename.
  - **`src/components/`**: Reusable UI components for your pages and layouts.
  - **`src/layouts/`**: Template components that provide a common structure for your pages.
  - **`src/styles/`**: Global CSS or style files.

- **`public/`**: Static assets that will be copied to the build folder without processing.

## Core Concepts

### Components

Astro components (`.astro` files) are the building blocks of your site. They are HTML-only templating components with no client-side runtime.

An Astro component has two main parts:
1. **Component Script**: The "frontmatter" section between two `---` fences where you write JavaScript/TypeScript.
2. **Component Template**: The HTML/templating syntax that follows the script section.

```astro
---
// Component Script (JavaScript/TypeScript)
// Import components, fetch data, define variables, etc.
import SomeComponent from '../components/SomeComponent.astro';
const greeting = "Hello";
---

<!-- Component Template (HTML + JS Expressions) -->
<div>
  <h1>{greeting}, World!</h1>
  <SomeComponent />
</div>

<style>
  /* Scoped styles that only apply to this component */
  h1 {
    color: purple;
  }
</style>
```

**Best Practices for Components:**
- Organize related components in subdirectories within `src/components/`.
- Use descriptive, PascalCase names for component files (e.g., `NavBar.astro`).
- Keep components focused on a single responsibility.
- Extract reusable styles to separate files when shared across multiple components.

### Pages

Pages in Astro are just special components that live in the `src/pages/` directory and generate HTML pages for specific routes.

```astro
---
// src/pages/about.astro
// This will create a page at /about
import MainLayout from '../layouts/MainLayout.astro';
---

<MainLayout title="About Us">
  <h1>About Our Company</h1>
  <p>We are a small team dedicated to building amazing websites.</p>
</MainLayout>
```

**Best Practices for Pages:**
- Use layouts to maintain consistent page structure.
- Organize complex pages by breaking them into smaller components.
- For pages with similar structures, create a layout or template component.

### Layouts

Layouts are reusable page templates that help maintain consistent structure and styling across your site.

```astro
---
// src/layouts/MainLayout.astro
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';

interface Props {
  title: string;
}

const { title } = Astro.props;
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{title} - My Site</title>
  </head>
  <body>
    <Header />
    <main>
      <slot /> <!-- Page content will be inserted here -->
    </main>
    <Footer />
  </body>
</html>
```

**Best Practices for Layouts:**
- Create a base layout for common elements (head, nav, footer).
- Use `<slot />` to indicate where page content should be inserted.
- Create multiple layouts for different page types (blog posts, landing pages, etc.).
- Use props to pass page-specific information like titles or meta descriptions.

### Astro Islands

Astro Islands (or Component Islands) represent an architecture pattern where interactive UI components are isolated "islands" in a sea of static, lightweight HTML.

To use a UI framework component (like React, Vue, or Svelte), you need to:
1. Install the framework integration
2. Use the `client:` directive to specify when it should hydrate

```bash
# Add React integration
npx astro add react
```

```astro
---
// Import a React component
import ReactCounter from '../components/ReactCounter.jsx';
---

<div>
  <h1>Static content (no JavaScript)</h1>
  
  <!-- This React component will be hydrated when it becomes visible -->
  <ReactCounter client:visible />
</div>
```

**Client directives include:**
- `client:load` - Hydrate as soon as possible
- `client:idle` - Hydrate when the browser is idle
- `client:visible` - Hydrate when the component is visible in the viewport
- `client:media={query}` - Hydrate when a CSS media query is matched
- `client:only={framework}` - Skip server rendering and only render on the client

**Best Practices for Islands:**
- Use islands sparingly and only when client-side interactivity is necessary.
- Choose the most appropriate client directive to delay hydration when possible.
- Consider performance implications when adding interactive components.

## Building Your UI

### Astro Component Syntax

Astro components use an HTML-like syntax with support for JavaScript expressions:

```astro
---
const items = ["Item 1", "Item 2", "Item 3"];
const isLoggedIn = true;
---

<div>
  <!-- Conditionals -->
  {isLoggedIn ? <p>Welcome back!</p> : <p>Please log in</p>}
  
  <!-- Lists -->
  <ul>
    {items.map((item) => (
      <li>{item}</li>
    ))}
  </ul>
  
  <!-- Dynamic attributes -->
  <button class={isLoggedIn ? "logout" : "login"}>
    {isLoggedIn ? "Log Out" : "Log In"}
  </button>
</div>
```

Astro's template syntax is similar to JSX but renders to HTML during the build.

### Props

Astro components can receive data via props:

```astro
---
// Define props with TypeScript (optional but recommended)
interface Props {
  title: string;
  description?: string; // Optional prop
  items: string[];
}

// Access props
const { title, description = "Default description", items } = Astro.props;
---

<div>
  <h1>{title}</h1>
  {description && <p>{description}</p>}
  <ul>
    {items.map((item) => <li>{item}</li>)}
  </ul>
</div>
```

**Best Practices for Props:**
- Define prop types with TypeScript interfaces.
- Provide default values for optional props.
- Destructure props at the top of your component script.

### Slots

Slots allow you to inject content into predefined locations in your components:

```astro
---
// src/components/Card.astro
---

<div class="card">
  <div class="header">
    <slot name="header">Default Header</slot>
  </div>
  <div class="body">
    <slot /> <!-- Default/unnamed slot -->
  </div>
  <div class="footer">
    <slot name="footer">Default Footer</slot>
  </div>
</div>

<style>
  .card {
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1rem;
  }
  .header {
    font-weight: bold;
    margin-bottom: 0.5rem;
  }
  .footer {
    font-size: 0.8rem;
    margin-top: 0.5rem;
  }
</style>
```

Usage:

```astro
---
import Card from '../components/Card.astro';
---

<Card>
  <h2 slot="header">Special Announcement</h2>
  <p>This is the main content that goes in the default slot.</p>
  <p slot="footer">Posted on: April 1, 2023</p>
</Card>
```

**Best Practices for Slots:**
- Use the default (unnamed) slot for primary content.
- Use named slots for distinct areas of your component.
- Provide fallback content for slots that might be empty.

### Styling in Astro

Astro offers several approaches to styling:

1. **Scoped styles within components**:
   ```astro
   <style>
     /* Automatically scoped to this component */
     h1 { color: red; }
   </style>
   ```

2. **Global styles**:
   ```astro
   <style is:global>
     /* Applied globally */
     body { font-family: sans-serif; }
   </style>
   ```

3. **Importing CSS/SCSS files**:
   ```astro
   ---
   import '../styles/global.css';
   ---
   ```

4. **CSS Modules**:
   ```astro
   ---
   import styles from '../styles/home.module.css';
   ---
   
   <h1 class={styles.title}>Hello, world!</h1>
   ```

5. **Inline styles**:
   ```astro
   <div style={{ color: 'red', fontSize: '1.5rem' }}>
     Styled text
   </div>
   ```

6. **CSS Variables**:
   ```astro
   <style define:vars={{ textColor: 'purple' }}>
     h1 {
       color: var(--textColor);
     }
   </style>
   ```

**Best Practices for Styling:**
- Use component-scoped styles by default to avoid style conflicts.
- Keep global styles minimal and focused on consistent theming.
- Consider using CSS variables for theming and consistent values.
- For larger projects, organize styles with a methodology like BEM or use a framework like Tailwind CSS.

## Adding Content

### Markdown Integration

Astro has excellent support for Markdown content:

```markdown
---
# src/pages/posts/first-post.md
layout: ../../layouts/BlogPostLayout.astro
title: My First Blog Post
author: Astro Developer
date: 2023-04-01
---

# My First Blog Post

This is a paragraph of text in Markdown.

- This is a list item
- This is another list item

```

**Best Practices for Markdown:**
- Create a dedicated blog post layout.
- Use frontmatter for metadata (title, date, author, etc.).
- Organize markdown files in a logical directory structure.
- For more advanced features, consider using MDX integration.

### Content Collections

Content Collections (available since Astro 2.0) provide a type-safe way to organize and query your content:

1. Set up a collection schema:

```typescript
// src/content/config.ts
import { defineCollection, z } from 'astro:content';

const blogCollection = defineCollection({
  schema: z.object({
    title: z.string(),
    date: z.date(),
    author: z.string(),
    tags: z.array(z.string()).optional(),
    image: z.string().optional(),
  }),
});

export const collections = {
  'blog': blogCollection,
};
```

2. Create content in the collection:

```markdown
---
# src/content/blog/hello-world.md
title: Hello, World!
date: 2023-04-01
author: Astro Developer
tags: ["astro", "blogging"]
---

This is my first blog post!
```

3. Query and use the content:

```astro
---
// src/pages/blog.astro
import { getCollection } from 'astro:content';
import BlogPostCard from '../components/BlogPostCard.astro';

const blogPosts = await getCollection('blog');
const sortedPosts = blogPosts.sort((a, b) => b.data.date.getTime() - a.data.date.getTime());
---

<h1>My Blog</h1>
<div class="posts">
  {sortedPosts.map(post => (
    <BlogPostCard 
      title={post.data.title}
      date={post.data.date}
      author={post.data.author}
      tags={post.data.tags}
      url={`/blog/${post.slug}`}
    />
  ))}
</div>
```

4. Create dynamic routes for individual posts:

```astro
---
// src/pages/blog/[slug].astro
import { getCollection } from 'astro:content';
import BlogLayout from '../../layouts/BlogLayout.astro';

export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map(entry => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { Content } = await entry.render();
---

<BlogLayout frontmatter={entry.data}>
  <Content />
</BlogLayout>
```

**Best Practices for Content Collections:**
- Define strict schemas to ensure content consistency.
- Organize related content into separate collections.
- Use TypeScript for type safety in schemas.
- Implement sorting, filtering, and pagination for content lists.

### Image Optimization

Astro provides built-in image optimization through the `astro:assets` module:

```astro
---
import { Image } from 'astro:assets';
import myImage from '../assets/my-image.jpg';
---

<!-- Optimized image with automatic width/height -->
<Image src={myImage} alt="Description of my image" />

<!-- Custom dimensions -->
<Image 
  src={myImage}
  width={300}
  height={200}
  alt="Resized image"
  format="webp" 
/>

<!-- Remote images -->
<Image
  src="https://example.com/remote-image.jpg"
  width={300}
  height={200}
  alt="Remote image"
/>
```

**Best Practices for Images:**
- Always use the `Image` component for automatic optimization.
- Provide descriptive alt text for accessibility.
- Store commonly used images in `src/assets/`.
- Consider converting images to WebP format for better performance.
- Specify the `width` and `height` to prevent layout shifts.

### Data Fetching

Astro components can fetch data in their component script:

```astro
---
// Fetch data at build time
const response = await fetch('https://api.example.com/data');
const data = await response.json();

// This data is fetched once during build
console.log('This runs at build time, not in the browser!');
---

<ul>
  {data.map(item => <li>{item.name}</li>)}
</ul>
```

For SSR mode, you can fetch data on each request:

```astro
---
// This will run on every request when using SSR
const userAgent = Astro.request.headers.get('user-agent');
---

<p>Your user agent is: {userAgent}</p>
```

**Best Practices for Data Fetching:**
- For static sites, move complex or repetitive data fetching to separate utility functions.
- Use environment variables for API keys.
- Implement error handling for failed requests.
- Consider caching strategies for frequently accessed data.
- For authenticated or personalized content, use server endpoints or SSR.

## Integrations and Frameworks

### UI Frameworks

Astro allows you to use components from popular UI frameworks:

1. Install the integration:
```bash
# For React
npx astro add react

# For Vue
npx astro add vue

# For Svelte
npx astro add svelte

# For Solid
npx astro add solid-js
```

2. Create and use a framework component:

```jsx
// src/components/Counter.jsx (React)
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

```astro
---
// Use in an Astro component
import Counter from '../components/Counter.jsx';
---

<div>
  <h1>My Counter</h1>
  <Counter client:visible />
</div>
```

**Best Practices for UI Frameworks:**
- Choose the right client directive based on when you need interactivity.
- Only use framework components when you need interactivity.
- Keep framework-specific code in separate files from your Astro components.
- Be mindful of bundle size when adding multiple frameworks.

### Adding Tailwind CSS

Tailwind CSS is a popular utility-first CSS framework that works well with Astro:

1. Add the Tailwind integration:
```bash
npx astro add tailwind
```

2. Use Tailwind classes in your components:

```astro
<div class="max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden md:max-w-2xl">
  <div class="md:flex">
    <div class="p-8">
      <h1 class="text-2xl font-bold text-gray-900">Hello, Tailwind CSS!</h1>
      <p class="mt-2 text-gray-600">Using Tailwind with Astro is easy!</p>
    </div>
  </div>
</div>
```

**Best Practices for Tailwind:**
- Use `@apply` in component-scoped styles for repeated utility combinations.
- Set up a consistent color scheme and spacing scale in your Tailwind config.
- Use the `class:list` directive for conditional classes in Astro.
- Consider extracting common UI patterns into reusable components.

## Routing and Navigation

### File-based Routing

Astro uses file-based routing where files in the `src/pages/` directory automatically become routes:

```
src/pages/
├── index.astro          # -> example.com/
├── about.astro          # -> example.com/about
├── contact.astro        # -> example.com/contact
└── blog/
    ├── index.astro      # -> example.com/blog
    └── post-1.md        # -> example.com/blog/post-1
```

**Best Practices for Routing:**
- Use descriptive filenames that match the content's purpose.
- Group related pages in subdirectories.
- Create index files (`index.astro`) for directory root pages.
- Use consistent naming conventions.

### Dynamic Routes

Create dynamic routes using square brackets in the filename:

```astro
---
// src/pages/products/[productId].astro

export async function getStaticPaths() {
  const products = await fetchProducts();
  
  return products.map(product => ({
    params: { productId: product.id },
    props: { product },
  }));
}

const { product } = Astro.props;
---

<h1>{product.name}</h1>
<p>{product.description}</p>
<p>Price: ${product.price}</p>
```

For multiple parameters:

```astro
// src/pages/[category]/[product].astro
```

**Best Practices for Dynamic Routes:**
- Keep path-generating logic clean and well-documented.
- Handle 404 cases for invalid parameters.
- Consider performance with large datasets by using pagination.
- Use typed params with TypeScript.

### View Transitions

Astro provides built-in support for the View Transitions API for smoother page navigation:

1. Enable view transitions in your config:

```javascript
// astro.config.mjs
export default defineConfig({
  experimental: {
    viewTransitions: true
  }
});
```

2. Use the ViewTransition component in your layout:

```astro
---
// src/layouts/MainLayout.astro
import { ViewTransitions } from 'astro:transitions';
---
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>My Site</title>
    <ViewTransitions />
  </head>
  <body>
    <slot />
  </body>
</html>
```

3. Add transition directives to elements:

```astro
<h1 transition:name="title">Page Title</h1>
<img src="avatar.jpg" alt="User avatar" transition:name="avatar" />
```

**Best Practices for View Transitions:**
- Use consistent transition names across pages for connected elements.
- Add fallbacks for browsers that don't support view transitions.
- Keep transitions simple and subtle for the best user experience.
- Test transitions across different browsers and devices.

## Optimizing Your Site

### Performance Optimization

Astro sites are already optimized for performance, but here are additional best practices:

1. **Minimize JavaScript**:
   - Only use client directives when necessary.
   - Choose lighter alternatives for UI frameworks when possible.
   - Consider breaking large islands into smaller, more targeted components.

2. **Image Optimization**:
   - Always use Astro's `Image` component for automatic optimization.
   - Specify correct image dimensions to prevent layout shifts.
   - Use responsive images with appropriate sizes for different viewports.

3. **CSS Optimization**:
   - Keep global CSS minimal.
   - Use component-scoped styles for better isolation.
   - Consider adopting atomic CSS with Tailwind.

4. **Code Splitting**:
   - Break large pages into smaller components.
   - Use dynamic imports for large libraries or components.

5. **Asset Optimization**:
   - Minify and compress assets.
   - Use modern formats (WebP for images, WOFF2 for fonts).
   - Consider lazy loading for below-the-fold content.

### SEO Best Practices

Implement good SEO practices with these tips:

1. Create an SEO component:

```astro
---
// src/components/SEO.astro
interface Props {
  title: string;
  description: string;
  canonical?: string;
  image?: string;
  ogType?: 'website' | 'article';
}

const { 
  title, 
  description, 
  canonical = Astro.url.href,
  image,
  ogType = 'website'
} = Astro.props;

const siteUrl = Astro.site || Astro.url.origin;
const imageUrl = image ? new URL(image, siteUrl).href : undefined;
---

<!-- Basic Meta Tags -->
<title>{title}</title>
<meta name="description" content={description} />
<link rel="canonical" href={canonical} />

<!-- Open Graph / Facebook -->
<meta property="og:type" content={ogType} />
<meta property="og:url" content={canonical} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
{imageUrl && <meta property="og:image" content={imageUrl} />}

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={canonical} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
{imageUrl && <meta property="twitter:image" content={imageUrl} />}
```

2. Use the SEO component in your layouts:

```astro
---
import SEO from '../components/SEO.astro';
import MainLayout from './MainLayout.astro';

const { title, description, image } = Astro.props;
---

<MainLayout>
  <SEO
    title={title}
    description={description}
    image={image}
  />
  <slot />
</MainLayout>
```

**Additional SEO Tips:**
- Create a sitemap (use `@astrojs/sitemap` integration).
- Add a `robots.txt` file.
- Implement structured data (JSON-LD) for rich search results.
- Ensure good performance metrics (Core Web Vitals).
- Create descriptive URLs with proper slugs.

## Deployment

### Static Site Generation

By default, Astro builds static sites:

```bash
npm run build
```

This creates a `dist/` directory with static files that can be deployed to any static hosting service.

### Server-side Rendering

To enable SSR, add an adapter for your target hosting platform:

```bash
# For Node.js
npx astro add node

# For Vercel
npx astro add vercel

# For Netlify
npx astro add netlify

# For Cloudflare
npx astro add cloudflare
```

Then update your config:

```javascript
// astro.config.mjs
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  output: 'server',
  adapter: vercel(),
});
```

### Deployment Platforms

Popular platforms for deploying Astro sites:

1. **Netlify**:
   ```bash
   npx astro add netlify
   ```
   Create a `netlify.toml` file:
   ```toml
   [build]
     command = "npm run build"
     publish = "dist"
   ```

2. **Vercel**:
   ```bash
   npx astro add vercel
   ```

3. **Cloudflare Pages**:
   ```bash
   npx astro add cloudflare
   ```

4. **GitHub Pages**:
   ```javascript
   // astro.config.mjs
   export default defineConfig({
     site: 'https://yourusername.github.io',
     base: '/your-repo-name', // Remove if deploying to a custom domain
   });
   ```

**Best Practices for Deployment:**
- Use continuous integration/deployment (CI/CD) for automated builds.
- Set up preview deployments for pull requests.
- Configure proper caching headers for static assets.
- Monitor performance and errors in production.
- Use environment variables for sensitive information.

## Advanced Topics

### Environment Variables

Manage environment variables in Astro:

1. Create `.env` files for different environments:
   - `.env` - Loaded in all environments
   - `.env.development` - Loaded in development only
   - `.env.production` - Loaded in production only

2. Structure your environment variables:
   ```
   # Public variables (available in client-side code)
   PUBLIC_API_URL=https://api.example.com
   
   # Private variables (only available in server-side code)
   API_SECRET=your